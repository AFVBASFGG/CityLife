<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Life Balance: 100x100 Isometric City</title>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        /* --- CSS STYLING --- */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            z-index: 1;
            background-color: #c8e6c9;
            cursor: crosshair; /* Indicates building */
        }
        
        /* Cursor style when panning */
        #game-canvas.panning {
            cursor: grab;
        }
        #game-canvas.panning:active {
            cursor: grabbing;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: center;
            padding: 10px;
            pointer-events: auto;
        }

        .stats-bar {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: flex;
            gap: 20px;
            align-items: center;
            border: 1px solid #ccc;
        }

        .stat-item { display: flex; flex-direction: column; align-items: center; min-width: 60px; }
        .stat-label { font-size: 10px; text-transform: uppercase; color: #555; font-weight: bold; }
        .stat-value { font-size: 18px; font-weight: bold; color: #00796b; }

        .progress-bar {
            width: 60px; height: 6px; background: #eee; border-radius: 3px; margin-top: 4px; overflow: hidden;
        }
        .progress-fill { height: 100%; transition: width 0.5s ease; }

        .hud-bottom { padding: 20px; display: flex; justify-content: center; pointer-events: none; }

        .controls-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: flex;
            gap: 10px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 95%;
        }

        .tool-btn {
            width: 65px; height: 65px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.2s;
            user-select: none;
        }
        .tool-btn:hover { background: #f0f0f0; transform: translateY(-2px); }
        .tool-btn.active { border-color: #00838f; background: #e0f7fa; }
        .tool-icon { font-size: 24px; margin-bottom: 4px; }
        .tool-name { font-size: 9px; font-weight: bold; color: #444; }
        .tool-cost { font-size: 9px; color: #d84315; font-weight: bold; }

        #notification-area {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; gap: 5px; pointer-events: none;
        }
        .toast {
            background: rgba(0,0,0,0.8); color: white; padding: 8px 16px;
            border-radius: 20px; font-size: 14px; animation: fadeUp 2s forwards;
        }
        @keyframes fadeUp {
            0% { opacity: 0; transform: translateY(10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Help Text */
        .controls-hint {
            position: absolute; bottom: 10px; right: 10px;
            color: rgba(0,0,0,0.5); font-size: 12px; pointer-events: none;
            background: rgba(255,255,255,0.5); padding: 5px 10px; border-radius: 4px;
        }

        /* Graph Modal */
        #graph-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #fff; z-index: 100; display: none; flex-direction: column; pointer-events: auto;
        }
        #graph-header {
            padding: 15px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #ddd;
        }
        #graph-canvas { width: 100%; height: 100%; cursor: grab; }
        
        .btn {
            background: #00838f; color: white; border: none;
            padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;
        }
        .btn:hover { background: #006064; }
        .btn-secondary { background: #78909c; }
        .btn-secondary:hover { background: #546e7a; }
        
        .legend {
            position: absolute; bottom: 20px; left: 20px;
            background: #f9f9f9; padding: 10px; border-radius: 4px;
            border: 1px solid #ddd; font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="game-canvas"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stats-bar">
                <div class="stat-item">
                    <span class="stat-label">Income</span>
                    <span class="stat-value" id="val-income">0</span>
                    <div class="progress-bar"><div class="progress-fill" id="bar-income" style="width: 0%; background: gold;"></div></div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Happiness</span>
                    <span class="stat-value" id="val-happiness">0</span>
                    <div class="progress-bar"><div class="progress-fill" id="bar-happiness" style="width: 0%; background: #ffca28;"></div></div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Wellness</span>
                    <span class="stat-value" id="val-wellness">0</span>
                    <div class="progress-bar"><div class="progress-fill" id="bar-wellness" style="width: 0%; background: #66bb6a;"></div></div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Balance</span>
                    <span class="stat-value" id="val-balance">0%</span>
                </div>
            </div>
        </div>

        <div id="notification-area"></div>

        <div class="hud-bottom">
            <div class="controls-panel" id="toolbar"></div>
        </div>
        
        <div style="position:absolute; top: 10px; right: 10px; pointer-events: auto;">
            <button class="btn btn-secondary" onclick="window.GameApp.toggleGraph()">üï∏Ô∏è Life Graph</button>
        </div>

        <div class="controls-hint">
            Left Click: Build | Right Click + Drag: Pan Map | Scroll: Zoom
        </div>
    </div>

    <div id="graph-modal">
        <div id="graph-header">
            <h2>Life Balance Network</h2>
            <div>
                <button class="btn btn-secondary" onclick="GraphView.resetZoom()">Reset View</button>
                <button class="btn" onclick="window.GameApp.toggleGraph()">Close Graph</button>
            </div>
        </div>
        <canvas id="graph-canvas"></canvas>
        <div class="legend">
            <div style="color:#ef5350">‚óè House (Needs)</div>
            <div style="color:#42a5f5">‚óè Work (Source)</div>
            <div style="color:#66bb6a">‚óè Care (Leisure)</div>
        </div>
    </div>

<script>
/**
 * CONFIGURATION
 */
const CONFIG = {
    gridSize: 100,      // 100 tiles wide
    tileSize: 20,       // 20 units per tile = 2000x2000 world
    tickRate: 1000,
    colors: {
        grass: 0xc8e6c9,
        road: 0x546e7a,
        highlight: 0xffeb3b,
        error: 0xff5252
    }
};

const BUILDINGS = {
    road: { id: 'road', name: 'Road', cost: 10, type: 'infra', icon: 'üõ£Ô∏è', color: CONFIG.colors.road, height: 0.5, influenceRange: 0 },
    house: { id: 'house', name: 'House', cost: 100, type: 'residential', icon: 'üè†', color: 0xef5350, height: 4, influenceRange: 10, needsRoad: true },
    park: { id: 'park', name: 'Park', cost: 150, type: 'care', icon: 'üå≥', color: 0x66bb6a, height: 1, influenceRange: 8, needsRoad: true },
    mall: { id: 'mall', name: 'Mall', cost: 200, type: 'care', icon: 'üõçÔ∏è', color: 0xab47bc, height: 3, influenceRange: 6, needsRoad: true },
    hospital: { id: 'hospital', name: 'Hospital', cost: 400, type: 'care', icon: 'üè•', color: 0xffffff, height: 5, influenceRange: 12, needsRoad: true },
    school: { id: 'school', name: 'School', cost: 300, type: 'care', icon: 'üè´', color: 0xec407a, height: 4, influenceRange: 15, needsRoad: true },
    office: { id: 'office', name: 'Office', cost: 250, type: 'work', icon: 'üè¢', color: 0x42a5f5, height: 8, influenceRange: 10, needsRoad: true },
    factory: { id: 'factory', name: 'Factory', cost: 300, type: 'work', icon: 'üè≠', color: 0x8d6e63, height: 6, influenceRange: 12, needsRoad: true }
};

/**
 * 3D ENGINE WITH PAN/ZOOM
 */
class Engine {
    constructor() {
        console.log("Initializing Engine (100x100)...");
        const container = document.getElementById('game-canvas');
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(CONFIG.colors.grass);

        // 1. Setup Isometric Camera
        const aspect = window.innerWidth / window.innerHeight;
        // View Size (Frustum). 
        // 100 tiles * 20 units = 2000 units total width.
        // We want to see about 30-40 tiles (600-800 units) at a time.
        const viewSize = 600; 

        this.camera = new THREE.OrthographicCamera(
            -viewSize * aspect, viewSize * aspect,
            viewSize, -viewSize,
            1, 5000
        );
        
        // Isometric Position: (-1, 1, 1) vector
        this.camera.position.set(-1000, 1000, 1000);
        this.camera.lookAt(0, 0, 0);

        // 2. Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(this.renderer.domElement);

        // 3. Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(-500, 1000, 500);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        // Large shadow box for the 2000x2000 world
        dirLight.shadow.camera.left = -1500;
        dirLight.shadow.camera.right = 1500;
        dirLight.shadow.camera.top = 1500;
        dirLight.shadow.camera.bottom = -1500;
        this.scene.add(dirLight);

        // 4. Ground Visuals
        const worldSize = CONFIG.gridSize * CONFIG.tileSize;
        const gridHelper = new THREE.GridHelper(worldSize, CONFIG.gridSize, 0xa5d6a7, 0xb2dfdb);
        this.scene.add(gridHelper);

        this.cityGroup = new THREE.Group();
        this.scene.add(this.cityGroup);
        
        // 5. Interaction Plane (Large enough for 100x100)
        const geometry = new THREE.PlaneGeometry(worldSize * 2, worldSize * 2);
        geometry.rotateX(-Math.PI / 2);
        this.plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ visible: false }));
        this.scene.add(this.plane);

        // Cursor
        this.cursorMesh = new THREE.Mesh(
            new THREE.BoxGeometry(CONFIG.tileSize, 1, CONFIG.tileSize),
            new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true })
        );
        this.scene.add(this.cursorMesh);

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        // Controls State
        this.isPanning = false;
        this.startMouse = { x: 0, y: 0 };
        this.startCameraPos = new THREE.Vector3();

        // Event Listeners
        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('mousemove', (e) => this.onMouseMove(e));
        window.addEventListener('mousedown', (e) => this.onMouseDown(e));
        window.addEventListener('mouseup', () => this.onMouseUp());
        window.addEventListener('wheel', (e) => this.onWheel(e));
        window.addEventListener('contextmenu', e => e.preventDefault()); // Block context menu for right-click pan

        console.log("Engine Ready.");
    }

    // Pan Logic
    onMouseDown(event) {
        if (event.button === 2) { // Right click
            this.isPanning = true;
            this.startMouse = { x: event.clientX, y: event.clientY };
            this.startCameraPos.copy(this.camera.position);
            document.getElementById('game-canvas').classList.add('panning');
        }
    }

    onMouseUp() {
        this.isPanning = false;
        document.getElementById('game-canvas').classList.remove('panning');
    }

    onWheel(event) {
        // Zoom logic for Orthographic Camera
        // Adjusting zoom property preserves the aspect ratio setup we did
        const zoomSpeed = 0.001;
        const newZoom = this.camera.zoom - event.deltaY * zoomSpeed;
        
        // Clamp zoom
        if (newZoom > 0.1 && newZoom < 5) {
            this.camera.zoom = newZoom;
            this.camera.updateProjectionMatrix();
        }
    }

    onResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const viewSize = 600 / this.camera.zoom; // Adjust base size by zoom
        this.camera.left = -viewSize * aspect;
        this.camera.right = viewSize * aspect;
        this.camera.top = viewSize;
        this.camera.bottom = -viewSize;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    onMouseMove(event) {
        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        if (this.isPanning) {
            // Calculate delta
            const deltaX = event.clientX - this.startMouse.x;
            const deltaY = event.clientY - this.startMouse.y;

            // In Three.js orthographic, moving mouse X corresponds to moving camera X/Z (isometric diagonal)
            // However, simple screen-space panning is complex with isometric angles.
            // Approximation: Move camera in World Plane opposite to mouse
            const panSpeed = 1 / this.camera.zoom;
            
            // Isometric Vectors
            // Screen X -> World (-1, 0, 1) 
            // Screen Y -> World (1, 0, 1)
            // We normalize these.
            
            const vecX = new THREE.Vector3(-1, 0, 1).normalize().multiplyScalar(deltaX * panSpeed * 1.5);
            const vecY = new THREE.Vector3(1, 0, 1).normalize().multiplyScalar(deltaY * panSpeed * 1.5);

            this.camera.position.copy(this.startCameraPos).sub(vecX).add(vecY);
            // Don't change height (Y), keep isometric angle
            
        } else {
            // Raycasting for building
            this.raycaster.setFromCamera(this.mouse, this.camera);
            const intersects = this.raycaster.intersectObject(this.plane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const x = Math.floor(point.x / CONFIG.tileSize) * CONFIG.tileSize + CONFIG.tileSize / 2;
                const z = Math.floor(point.z / CONFIG.tileSize) * CONFIG.tileSize + CONFIG.tileSize / 2;
                
                this.cursorMesh.position.set(x, 0.5, z);
                this.cursorMesh.visible = true;
                
                if (window.GameApp) window.GameApp.onGridHover(x, z);
            } else {
                this.cursorMesh.visible = false;
                if (window.GameApp) window.GameApp.onGridHover(null, null);
            }
        }
    }

    onClick(event) {
        if (event.button === 0 && this.cursorMesh.visible && window.GameApp) { // Left click
            window.GameApp.onGridClick(this.cursorMesh.position.x, this.cursorMesh.position.z);
        }
    }

    render() {
        this.renderer.render(this.scene, this.camera);
    }

    addBuildingMesh(x, z, typeKey) {
        const data = BUILDINGS[typeKey];
        const group = new THREE.Group();
        const material = new THREE.MeshLambertMaterial({ color: data.color });
        
        let geometry;
        if (typeKey === 'road') {
            geometry = new THREE.BoxGeometry(CONFIG.tileSize, 0.5, CONFIG.tileSize);
        } else if (typeKey === 'house') {
            geometry = new THREE.BoxGeometry(14, 4, 14);
            const roofGeo = new THREE.ConeGeometry(10, 6, 4);
            const roofMat = new THREE.MeshLambertMaterial({ color: 0xb71c1c });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 5; roof.rotation.y = Math.PI / 4;
            group.add(roof);
        } else if (typeKey === 'office') {
            geometry = new THREE.BoxGeometry(16, 8, 16);
            const edgeGeo = new THREE.EdgesGeometry(geometry);
            const edgeMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            group.add(new THREE.LineSegments(edgeGeo, edgeMat));
        } else if (typeKey === 'factory') {
            geometry = new THREE.BoxGeometry(18, 6, 18);
            const chimGeo = new THREE.CylinderGeometry(2, 2, 8);
            const chim = new THREE.Mesh(chimGeo, new THREE.MeshLambertMaterial({ color: 0x555555 }));
            chim.position.set(5, 7, 5); group.add(chim);
        } else if (typeKey === 'park') {
            geometry = new THREE.CylinderGeometry(0.1, 8, 1, 8);
            for(let i=0; i<3; i++) {
                const treeGeo = new THREE.ConeGeometry(3, 6, 8);
                const tree = new THREE.Mesh(treeGeo, new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                tree.position.set(Math.sin(i)*6, 3, Math.cos(i)*6); group.add(tree);
            }
        } else {
            geometry = new THREE.BoxGeometry(16, data.height, 16);
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = data.height / 2;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);
        group.position.set(x, 0, z);
        group.scale.set(0,0,0);
        
        this.cityGroup.add(group);
        return group;
    }

    removeBuildingMesh(mesh) {
        this.cityGroup.remove(mesh);
    }
}

/**
 * GAME LOGIC (Adapted for Center Origin)
 */
class Game {
    constructor() {
        console.log("Initializing Game...");
        this.grid = {};
        this.money = 2000;
        this.selectedTool = null;
        this.metrics = { income: 0, happiness: 50, wellness: 50, balance: 50 };

        this.initUI();
        this.initExampleCity(); // Builds at 0,0
        
        this.simulationInterval = setInterval(() => this.simulate(), CONFIG.tickRate);
    }

    initUI() {
        const toolbar = document.getElementById('toolbar');
        Object.values(BUILDINGS).forEach(b => {
            const btn = document.createElement('div');
            btn.className = 'tool-btn';
            btn.innerHTML = `<div class="tool-icon">${b.icon}</div><div class="tool-name">${b.name}</div><div class="tool-cost">$${b.cost}</div>`;
            btn.onclick = () => this.selectTool(b.id, btn);
            toolbar.appendChild(btn);
        });

        const bulldozer = document.createElement('div');
        bulldozer.className = 'tool-btn';
        bulldozer.innerHTML = `<div class="tool-icon">üöß</div><div class="tool-name">Demolish</div>`;
        bulldozer.onclick = () => this.selectTool('demolish', bulldozer);
        toolbar.appendChild(bulldozer);
    }

    initExampleCity() {
        // Center is 0,0
        const step = CONFIG.tileSize;

        // Road Cross
        this.buildAt(0, 0, 'road');
        this.buildAt(0, step, 'road');
        this.buildAt(0, -step, 'road');
        this.buildAt(step, 0, 'road');
        this.buildAt(-step, 0, 'road');

        // Buildings
        this.buildAt(-step, -step, 'house');
        this.buildAt(step, -step, 'office');
        this.buildAt(-step, step, 'park');
        this.buildAt(step, step, 'factory');
        
        this.showToast("Welcome! Use Right-Click to pan.");
    }

    selectTool(toolId, btnElement) {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btnElement.classList.add('active');
        this.selectedTool = toolId;
    }

    onGridHover(x, z) {
        if (!window.Engine) return;
        if (this.selectedTool === 'demolish') {
            window.Engine.cursorMesh.material.color.setHex(CONFIG.colors.error);
        } else if (this.getBuildingAt(x, z)) {
            window.Engine.cursorMesh.material.color.setHex(CONFIG.colors.error); 
        } else {
            window.Engine.cursorMesh.material.color.setHex(CONFIG.colors.highlight);
        }
    }

    onGridClick(x, z) {
        if (!this.selectedTool) return;
        const existing = this.getBuildingAt(x, z);

        if (this.selectedTool === 'demolish') {
            if (existing) this.removeBuilding(x, z);
            return;
        }

        if (existing) {
            this.showToast("Space occupied!", "error");
            return;
        }

        const data = BUILDINGS[this.selectedTool];
        if (this.money < data.cost) {
            this.showToast("Insufficient Funds!", "error");
            return;
        }

        if (data.needsRoad) {
            const neighbors = [
                {x: x + CONFIG.tileSize, z: z}, {x: x - CONFIG.tileSize, z: z},
                {x: x, z: z + CONFIG.tileSize}, {x: x, z: z - CONFIG.tileSize}
            ];
            const hasRoad = neighbors.some(n => {
                const b = this.getBuildingAt(n.x, n.z);
                return b && b.type === 'road';
            });
            if (!hasRoad) {
                this.showToast("Must be connected to a road!", "error");
                return;
            }
        }

        this.buildAt(x, z, this.selectedTool);
    }

    buildAt(x, z, type) {
        const data = BUILDINGS[type];
        this.money -= data.cost;
        const mesh = window.Engine.addBuildingMesh(x, z, type);
        
        let s = 0;
        const anim = setInterval(() => {
            s += 0.1;
            mesh.scale.set(s,s,s);
            if(s >= 1) clearInterval(anim);
        }, 16);

        const id = Math.random().toString(36).substr(2, 9);
        this.grid[`${x},${z}`] = { type, mesh, id, x, z };
        this.updateGraph();
    }

    removeBuilding(x, z) {
        const key = `${x},${z}`;
        const b = this.grid[key];
        if (b) {
            this.money += Math.floor(BUILDINGS[b.type].cost * 0.5);
            window.Engine.removeBuildingMesh(b.mesh);
            delete this.grid[key];
            this.updateGraph();
        }
    }

    getBuildingAt(x, z) {
        return this.grid[`${x},${z}`];
    }

    showToast(msg, type='info') {
        const el = document.createElement('div');
        el.className = 'toast';
        if(type === 'error') el.style.background = 'rgba(211, 47, 47, 0.9)';
        el.innerText = msg;
        const area = document.getElementById('notification-area');
        area.appendChild(el);
        setTimeout(() => el.remove(), 2000);
    }

    simulate() {
        let income = 0, happiness = 50, wellness = 50;
        const buildings = Object.values(this.grid);
        const houses = buildings.filter(b => b.type === 'house');
        const works = buildings.filter(b => ['office', 'factory'].includes(b.type));
        const cares = buildings.filter(b => ['park', 'mall', 'hospital', 'school'].includes(b.type));

        const getDistance = (start, targetTypes) => {
            if (!start) return 9999;
            let queue = [start];
            let visited = new Set();
            let distMap = new Map();
            visited.add(`${start.x},${start.z}`);
            distMap.set(`${start.x},${start.z}`, 0);

            while (queue.length > 0) {
                let curr = queue.shift();
                const currB = this.getBuildingAt(curr.x, curr.z);
                if (currB && currB !== start && targetTypes.includes(currB.type)) {
                    return distMap.get(`${curr.x},${curr.z}`);
                }
                const neighbors = [
                    {x: curr.x + CONFIG.tileSize, z: curr.z}, {x: curr.x - CONFIG.tileSize, z: curr.z},
                    {x: curr.x, z: curr.z + CONFIG.tileSize}, {x: curr.x, z: curr.z - CONFIG.tileSize}
                ];
                for (let n of neighbors) {
                    const key = `${n.x},${n.z}`;
                    if (!visited.has(key)) {
                        const tileContent = this.getBuildingAt(n.x, n.z);
                        if (tileContent && tileContent.type === 'road') {
                            visited.add(key);
                            distMap.set(key, distMap.get(`${curr.x},${curr.z}`) + 1);
                            queue.push(n);
                        }
                    }
                }
            }
            return 9999;
        };

        works.forEach(w => {
            if (w.type === 'factory') {
                income += 50;
                houses.forEach(h => {
                    const d = getDistance(w, ['house']);
                    if (d < 10) happiness -= (10 - d) * 2;
                });
            } else if (w.type === 'office') {
                const d = getDistance(w, ['house']);
                if (d < 15) income += Math.max(0, 80 - (d * 5));
                if (happiness > 60) income += 20;
            }
        });

        cares.forEach(c => {
            const range = BUILDINGS[c.type].influenceRange;
            houses.forEach(h => {
                const d = getDistance(c, ['house']);
                if (d <= range) {
                    const strength = 1 - (d / range);
                    if (['park', 'mall'].includes(c.type)) happiness += (strength * 5);
                    if (['hospital', 'school'].includes(c.type)) wellness += (strength * 5);
                }
            });
        });

        happiness = Math.max(0, Math.min(100, happiness));
        wellness = Math.max(0, Math.min(100, wellness));
        income = Math.floor(income);
        this.money += income;

        const incomeFactor = Math.min(1, income / 100);
        this.metrics.balance = Math.floor(((happiness + wellness) / 2) * incomeFactor);
        this.metrics.happiness = happiness;
        this.metrics.wellness = wellness;
        this.metrics.income = income;

        this.updateUI();
        this.updateGraph();
    }

    updateUI() {
        document.getElementById('val-income').innerText = this.metrics.income;
        document.getElementById('bar-income').style.width = Math.min(100, (this.metrics.income / 200) * 100) + '%';
        
        document.getElementById('val-happiness').innerText = Math.floor(this.metrics.happiness);
        document.getElementById('bar-happiness').style.width = this.metrics.happiness + '%';
        document.getElementById('bar-happiness').style.backgroundColor = this.metrics.happiness < 40 ? '#ef5350' : '#ffca28';

        document.getElementById('val-wellness').innerText = Math.floor(this.metrics.wellness);
        document.getElementById('bar-wellness').style.width = this.metrics.wellness + '%';

        document.getElementById('val-balance').innerText = this.metrics.balance + '%';
    }

    toggleGraph() {
        const modal = document.getElementById('graph-modal');
        if (modal.style.display === 'flex') {
            modal.style.display = 'none';
        } else {
            modal.style.display = 'flex';
            GraphView.init();
            this.updateGraph();
        }
    }

    updateGraph() {
        if (document.getElementById('graph-modal').style.display !== 'flex') return;
        GraphView.setData(Object.values(this.grid), this.metrics);
    }
}

/**
 * GRAPH VIEW (Unchanged logic, just included for completeness)
 */
const GraphView = {
    canvas: null, ctx: null, nodes: [], edges: [],
    camera: { x: 0, y: 0, zoom: 1 }, isDragging: false, lastMouse: { x: 0, y: 0 }, animationFrame: null,

    init() {
        this.canvas = document.getElementById('graph-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.canvas.addEventListener('mousedown', (e) => { this.isDragging = true; this.lastMouse = { x: e.clientX, y: e.clientY }; });
        window.addEventListener('mouseup', () => this.isDragging = false);
        window.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                this.camera.x += e.clientX - this.lastMouse.x;
                this.camera.y += e.clientY - this.lastMouse.y;
                this.lastMouse = { x: e.clientX, y: e.clientY };
            }
        });
        this.canvas.addEventListener('wheel', (e) => { e.preventDefault(); this.camera.zoom *= e.deltaY > 0 ? 0.9 : 1.1; });
        this.loop();
    },
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; },
    resetZoom() { this.camera = { x: 0, y: 0, zoom: 1 }; },
    setData(buildings, metrics) {
        const colors = { residential: '#ef5350', work: '#42a5f5', care: '#66bb6a', infra: '#ffa726' };
        this.nodes = buildings.map(b => {
            const data = BUILDINGS[b.type];
            const existing = this.nodes.find(n => n.id === b.id);
            return {
                id: b.id,
                x: existing ? existing.x : (Math.random() - 0.5) * 200,
                y: existing ? existing.y : (Math.random() - 0.5) * 200,
                vx: 0, vy: 0, radius: b.type === 'road' ? 3 : 8,
                color: colors[data.type], type: b.type
            };
        });
        this.edges = [];
        const skip = ['road'];
        for (let i = 0; i < buildings.length; i++) {
            for (let j = i + 1; j < buildings.length; j++) {
                const b1 = buildings[i], b2 = buildings[j];
                if (skip.includes(b1.type) || skip.includes(b2.type)) continue;
                let connected = false, weight = 0, positive = true;
                if ((b1.type === 'house' && ['office','factory'].includes(b2.type)) || 
                    (b2.type === 'house' && ['office','factory'].includes(b1.type))) {
                    connected = true; weight = 5; positive = true;
                } else if ((b1.type === 'house' && ['park','hospital','mall'].includes(b2.type)) ||
                           (b2.type === 'house' && ['park','hospital','mall'].includes(b1.type))) {
                    connected = true; weight = 4; positive = true;
                } else if ((b1.type === 'factory' && ['park','mall','house'].includes(b2.type)) ||
                           (b2.type === 'factory' && ['park','mall','house'].includes(b1.type))) {
                    connected = true; weight = 6; positive = false;
                }
                if (connected) this.edges.push({ source: this.nodes.find(n => n.id === b1.id), target: this.nodes.find(n => n.id === b2.id), weight, positive });
            }
        }
    },
    loop() {
        this.updatePhysics();
        this.draw();
        this.animationFrame = requestAnimationFrame(() => this.loop());
    },
    updatePhysics() {
        for (let i = 0; i < this.nodes.length; i++) {
            for (let j = i + 1; j < this.nodes.length; j++) {
                const a = this.nodes[i], b = this.nodes[j];
                const dx = a.x - b.x, dy = a.y - b.y;
                let dist = Math.sqrt(dx*dx + dy*dy) || 0.1;
                const force = 200 / (dist * dist);
                const fx = (dx / dist) * force, fy = (dy / dist) * force;
                a.vx += fx; a.vy += fy; b.vx -= fx; b.vy -= fy;
            }
        }
        for (let edge of this.edges) {
            const a = edge.source, b = edge.target;
            const dx = b.x - a.x, dy = b.y - a.y, dist = Math.sqrt(dx*dx + dy*dy);
            const len = 100 - (edge.weight * 5);
            const force = (dist - len) * 0.05;
            const fx = (dx / dist) * force, fy = (dy / dist) * force;
            a.vx += fx; a.vy += fy; b.vx -= fx; b.vy -= fy;
        }
        for (let node of this.nodes) {
            node.vx -= node.x * 0.01; node.vy -= node.y * 0.01;
            node.vx *= 0.9; node.vy *= 0.9;
            node.x += node.vx; node.y += node.vy;
        }
    },
    draw() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.save();
        ctx.translate(this.canvas.width / 2 + this.camera.x, this.canvas.height / 2 + this.camera.y);
        ctx.scale(this.camera.zoom, this.camera.zoom);
        for (let edge of this.edges) {
            ctx.beginPath();
            ctx.moveTo(edge.source.x, edge.source.y); ctx.lineTo(edge.target.x, edge.target.y);
            ctx.lineWidth = edge.weight / 2;
            ctx.strokeStyle = edge.positive ? 'rgba(100, 221, 23, 0.4)' : 'rgba(229, 57, 53, 0.5)';
            ctx.stroke();
        }
        for (let node of this.nodes) {
            ctx.beginPath(); ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
            ctx.fillStyle = node.color; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        }
        ctx.restore();
    }
};

/**
 * INITIALIZATION
 */
window.onload = function() {
    console.log("Starting 100x100 Isometric City...");
    
    if (typeof THREE === 'undefined') {
        alert("Error: Three.js library failed to load.");
        return;
    }

    try {
        window.Engine = new Engine();
        window.Game = new Game();
        window.GameApp = window.Game;

        // Handle Left Click (Build) separate from Right Click (Pan)
        document.getElementById('game-canvas').addEventListener('click', (e) => window.Engine.onClick(e));

        function animate() {
            requestAnimationFrame(animate);
            if (window.Engine) window.Engine.render();
        }
        animate();
        
        console.log("Game Started.");
    } catch (e) {
        console.error("Initialization Error:", e);
    }
};
</script>
</body>
</html>